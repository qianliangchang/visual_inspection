<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.05.0.1">
<procedure name="main">
<interface/>
<body>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'black', WindowHandle)</l>
<c>*先关闭活动图形窗口，再打开这个窗口，标识符为WindowHandle；</c>
<c>*相对于界面左上角第0行、第0列，大小是我相机的拍照比例，颜色为黑色。</c>
<l>*open_framegrabber ('MindVision11', 1, 1, 0, 0, 0, 0, 'progressive', 8, 'Gray', -1, 'false', 'auto', 'Camera MV-U130RC#C17D8221-3', 0, -1, AcqHandle)</l>
<c>*DirectShow是笔记本摄像头或者其他DirectShow的摄像头，MindVision11是我相机的摄像头；</c>
<c>* 注意摄像头的名称,可以用工具栏中的“助手”——打开新的Image Acquisition获取摄像头及插入代码</c>
<l>*grab_image_start (AcqHandle, -1)</l>
<l>*while (true)</l>
<l>* grab_image_async (Image, AcqHandle, -1) </l>
<c></c>
<c>* Calibration 01: Code generated by Calibration 01</c>
<l>*CamParOriginal:= [0.01629,-2024.24,8.30436e-006,8.3e-006,710.402,361.975,1280,960]</l>
<l>*CameraPose := [-0.0236413,0.0135896,0.152813,16.2821,3.05758,76.5791,0]</l>
<c>*上面是我相机的标定量，根据自己相机标定填写，此段代码不可直接用</c>
<c></c>
<l>*CamParVirtualFixed:=CamParOriginal  </l>
<l>*CamParVirtualFixed[1]:=0  </l>
<c>*上面是标定时候的参数设置</c>
<c></c>
<l>*gen_radial_distortion_map(MapFixed,CamParOriginal,CamParVirtualFixed,'bilinear')  </l>
<c>*生产径向畸变映射图，  </c>
<c>*mapfixed是输出，  </c>
<c>*CamParOriginal是标定后的参数，  </c>
<c>*CamParVirtualFixed也是输出的参数，  </c>
<c>*'bilinear'映射类型 </c>
<c></c>
<l>*map_image(Image,MapFixed,ImageRectifiedFixed)  </l>
<c>*利用映射，消除图像畸变算子 </c>
<c></c>
<l>read_shape_model ('H:/projects/visual inspection/LabelRecognition/test03.shm', ModelID)</l>
<c>* 读取模板</c>
<l>read_image (Image, 'H:/projects/visual inspection/LabelRecognition/0.bmp')</l>
<l>get_image_size (Image, Image_Width, Image_Height)</l>
<c>* 读取图片</c>
<l>find_scaled_shape_model (Image, ModelID, rad(-180), rad(180), 0.5, 1.2, 0.2, 0, 0.5, 'none', 4, 0.9, Row, Column, Angle, Scale, Score)</l>
<c>*进行匹配</c>
<c>*Image 要搜索的图像</c>
<c>*ModelID 模板ID</c>
<c>*AngleStart 开始角度加rad(90)是将弧度制转为角度值</c>
<c>*AngleExtent 角度范围</c>
<c>*ScaleMin 模板行方向缩放最小尺度</c>
<c>*ScaleMax 模板行方向缩放最大尺寸</c>
<c>*MinScore 最低匹配分值 百分比</c>
<c>*NumMatches 匹配实例的个数</c>
<c>*MaxOverlap 最大重叠 在有重叠时也可检测匹配</c>
<c>*SubPixel 是否亚像素精度</c>
<c>*NumLevels 金子塔层数</c>
<c>*Greediness 搜索贪婪度； 0安全慢；1块不稳定；其他就是介于中间值</c>
<c>*剩下的几个参数是匹配图像的位置状态等参数</c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<c>*返回匹配结果的轮廓</c>
<c></c>
<l>for I := 0 to |Score|-1 by 1</l>
<c>   *for循环查找匹配</c>
<l>    vector_angle_to_rigid (0, 0, 0, Row[I], Column[I], Angle[I], HomMat2DRotate)</l>
<c>   *单匹配计算刚性变换矩阵 为了显示匹配图像</c>
<l>    hom_mat2d_scale (HomMat2DRotate, Scale[I], Scale[I], Row[I], Column[I], HomMat2DScale)</l>
<c>    *添加一个扩展到一个均匀的二维变换矩阵 为了显示匹配图像</c>
<l>    affine_trans_contour_xld (ModelContours, ModelTrans, HomMat2DScale)       </l>
<c>    *应用任意二维仿射变换XLD轮廓 为了显示匹配图像</c>
<l>    disp_message (WindowHandle,Score[I],'image', Row[I], Column[I]+100, 'red', 'false') </l>
<c>    *添加文本</c>
<l>    dev_display (ModelTrans)</l>
<c>    *显示模型 为了显示匹配图像</c>
<c>    ********************提取当前匹配到的区域**************************</c>
<c>    *填充区域</c>
<l>    gen_region_contour_xld(ModelTrans,Region,'filled')</l>
<c>    *提取当前区域</c>
<l>    reduce_domain (Image, Region, sub_Image)</l>
<l>    area_center (sub_Image, ImageReduced_Area, ImageReduced_Row, ImageReduced_Column)</l>
<c>    </c>
<l>*      get_image_size (sub_Image, sub_Image_Width, sub_Image_Height)</l>
<c>    </c>
<l>    *draw_rectangle1 (WindowHandle, Row11, Column11, Row21, Column21)</l>
<l>    *gen_rectangle1 (Rectangle, Row11, Column11, Row21, Column21)</l>
<l>    *reduce_domain (Image, Rectangle, ImageReduced1)</l>
<l>    *gen_rectangle1 (Region, ImageReduced_Row-sub_Image_Width/2, ImageReduced_Row-ImageReduced_Column/2, ImageReduced_Row+sub_Image_Width/2, ImageReduced_Row+ImageReduced_Column/2)</l>
<c>   </c>
<c>    *旋转</c>
<l>    *rotate_image (ImageReduced, ImageRotate, rad(90), 'constant')</l>
<c>    *开辟一个旋转矩阵</c>
<l>    *hom_mat2d_identity (HomMat2D)</l>
<c>    *为旋转矩阵赋值</c>
<c>    *HomMat2D是输入的旋转矩阵</c>
<c>    *Phi是输入的旋转角度</c>
<c>    *Px和Py分别是输入的旋转中心x坐标值和y坐标值</c>
<c>    *HomMat2DRotate是输出的旋转矩阵</c>
<l>    *hom_mat2d_rotate(HomMat2D,rad(90), ImageReduced_Row, ImageReduced_Column,HomMat2DRotate)</l>
<c>    *实施旋转</c>
<c>    *Image : ImageAffinTrans分别为输入输出图像</c>
<c>    *HomMat2DRotate是赋值后的旋转矩阵。注意：是赋值后的</c>
<c>    *Interpolation是内插方式，默认为'constant' </c>
<c>    *AdaptImageSize是bool变量，判断输出图像的大小是否发生变化</c>
<c>    * 旋转region</c>
<l>    *affine_trans_region (Region, RegionAffineTrans, HomMat2DRotate, 'nearest_neighbor')</l>
<c>    * 旋转整个图片</c>
<l>    *affine_trans_image(Image, ImageAffinTrans, HomMat2DRotate, 'constant', 'false')</l>
<c>    * 提取转转后对应的区域</c>
<l>    *reduce_domain (ImageAffinTrans, RegionAffineTrans, ImageReduced1)</l>
<c>    </c>
<c>    **************************识别文字**************************************</c>
<c>    * Create Automatic Text Reader and set some parameters</c>
<l>    create_text_model_reader ('auto', 'Industrial_0-9A-Z_Rej.omc', TextModel)</l>
<c>    * Read the "best before" date</c>
<l>    find_text (sub_Image, TextModel, TextResultID)</l>
<c>    * Display the segmentation results</c>
<l>    get_text_object (Characters, TextResultID, 'all_lines')</l>
<l>    dev_display (sub_Image)</l>
<l>    dev_display (Characters)</l>
<c>    * Display the reading results</c>
<l>    get_text_result (TextResultID, 'class', Classes)</l>
<l>    *area_center (Characters, Area, Row, Column)</l>
<l>    *disp_message (WindowHandle, Classes, 'image', 80, Column[I] - 3, 'green', 'false')</l>
<l>    stop()</l>
<l>*clear_ocr_class_mlp (OCRHandle)</l>
<c></c>
<c></c>
<c></c>
<c>     </c>
<c>     </c>
<l>endfor</l>
<c> </c>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<c>* ****</c>
<c>* step: destroy model</c>
<c>* ****</c>
<l>clear_shape_model (ModelID)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
